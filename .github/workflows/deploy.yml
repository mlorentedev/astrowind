name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Frontend CI", "Backend CI"]
    branches: [master, develop]
    types:
      - completed
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (default: latest for production, develop for staging)'
        required: false
        type: string

jobs:
  version:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Determine version increment based on commit messages
      - name: Analyze Commit Messages
        id: commit-analysis
        run: |
          # Detect commit types
          BREAKING_CHANGES=$(git log --oneline | grep -c "BREAKING CHANGE")
          FEATURES=$(git log --oneline | grep -c "feat:")
          FIXES=$(git log --oneline | grep -c "fix:")

          # Determine version bump
          if [ "$BREAKING_CHANGES" -gt 0 ]; then
            echo "bump=major" >> $GITHUB_OUTPUT
          elif [ "$FEATURES" -gt 0 ]; then
            echo "bump=minor" >> $GITHUB_OUTPUT
          elif [ "$FIXES" -gt 0 ]; then
            echo "bump=patch" >> $GITHUB_OUTPUT
          else
            echo "bump=patch" >> $GITHUB_OUTPUT
          fi

      # Advanced tagging with semantic versioning
      - name: Bump Version
        uses: anothrNick/github-tag-action@1.64.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WITH_V: true
          RELEASE_BRANCHES: master
          DEFAULT_BUMP: ${{ steps.commit-analysis.outputs.bump }}
          
      # Optional: Generate detailed changelog
      - name: Generate Changelog
        id: changelog
        uses: heinrichreimer/github-changelog-generator-action@v2.3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      # Create GitHub Release with changelog
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          body: ${{ steps.changelog.outputs.changelog }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
            
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-env.outputs.version }}
    steps:
      - name: Set environment and version
        id: set-env
        run: |
          # Determine environment based on trigger
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Workflow dispatch: use inputs
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            
            if [[ -n "${{ github.event.inputs.version }}" ]]; then
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
              echo "version=latest" >> $GITHUB_OUTPUT
            else
              echo "version=develop" >> $GITHUB_OUTPUT
            fi
          else
            # Workflow run: based on branch
            if [[ "${{ github.event.workflow_run.head_branch }}" == "master" ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
              echo "version=latest" >> $GITHUB_OUTPUT
            else
              echo "environment=staging" >> $GITHUB_OUTPUT
              echo "version=develop" >> $GITHUB_OUTPUT
            fi
          fi

  deploy:
    name: Deploy to ${{ needs.prepare.outputs.environment }}
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ needs.prepare.outputs.environment }}
    concurrency: 
      group: deploy-${{ needs.prepare.outputs.environment }}
      cancel-in-progress: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        
      - name: Set env vars for environment
        run: |
          if [[ "${{ needs.prepare.outputs.environment }}" == "production" ]]; then
            echo "SSH_HOST=${{ secrets.PRODUCTION_HOST }}" >> $GITHUB_ENV
            echo "SSH_USER=${{ secrets.PRODUCTION_USERNAME }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=/opt/mlorente" >> $GITHUB_ENV
            echo "DOMAIN=mlorente.dev" >> $GITHUB_ENV
          else
            echo "SSH_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "SSH_USER=${{ secrets.STAGING_USERNAME }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=/opt/mlorente-staging" >> $GITHUB_ENV
            echo "DOMAIN=staging.mlorente.dev" >> $GITHUB_ENV
          fi
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      - name: Run deployment script
        run: |
          # Create the deployment script
          cat > deploy.sh <<'EOF'
          #!/bin/bash
          set -e
          
          # Deployment variables
          ENV="${{ needs.prepare.outputs.environment }}"
          VERSION="${{ needs.prepare.outputs.version }}"
          DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
          DOMAIN="${{ env.DOMAIN }}"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          echo "===== STARTING DEPLOYMENT ====="
          echo "Environment: ${ENV}"
          echo "Version: ${VERSION}"
          echo "Directory: ${DEPLOY_PATH}"
          echo "Domain: ${DOMAIN}"
          echo "==============================="
          
          # Create backup directory
          BACKUP_DIR="${DEPLOY_PATH}/backups/${TIMESTAMP}"
          mkdir -p "${BACKUP_DIR}"
          
          # Backup current configuration
          if [ -f "${DEPLOY_PATH}/.env" ]; then
            cp "${DEPLOY_PATH}/.env" "${BACKUP_DIR}/.env.backup"
          fi
          if [ -f "${DEPLOY_PATH}/docker-compose.yml" ]; then
            cp "${DEPLOY_PATH}/docker-compose.yml" "${BACKUP_DIR}/docker-compose.yml.backup"
          fi
          
          # Update configuration if necessary (using your repo's docker-compose.yml)
          echo "Updating docker-compose.yml..."
          cp docker-compose.yml "${DEPLOY_PATH}/"
          
          # Update Nginx config if it exists
          if [ -d "docker/nginx" ]; then
            echo "Updating Nginx configuration..."
            mkdir -p "${DEPLOY_PATH}/docker/nginx"
            cp -r docker/nginx/* "${DEPLOY_PATH}/docker/nginx/"
          fi
          
          # Set version in environment variables
          cd "${DEPLOY_PATH}"
          export TAG="${VERSION}"
          export DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
          
          # Pull latest images and restart containers
          echo "Pulling latest images..."
          docker-compose pull
          
          echo "Starting services..."
          docker-compose up -d
          
          # Verify deployment
          echo "Verifying deployment..."
          sleep 10
          
          # Check if containers are running
          if ! docker-compose ps | grep -q "Up"; then
            echo "Error: Deployment verification failed. Some containers are not running!"
            docker-compose logs
            exit 1
          fi
          
          # Clean old images to save disk space
          echo "Cleaning old images..."
          docker image prune -af --filter "until=24h" || true
          
          echo "===== DEPLOYMENT COMPLETED SUCCESSFULLY ====="
          echo "Application is available at: https://${DOMAIN}"
          EOF
          
          # Make script executable and run it
          chmod +x deploy.sh
          scp deploy.sh ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/deploy.sh
          scp docker-compose.yml ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/docker-compose.yml
          
          if [ -d "docker/nginx" ]; then
            ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p /tmp/docker/nginx"
            scp -r docker/nginx/* ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/docker/nginx/
          fi
          
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cd /tmp && ./deploy.sh"
      
      - name: Run health checks
        run: |
          echo "Running health checks for ${{ needs.prepare.outputs.environment }}..."
          
          # Wait for services to be fully available
          sleep 20
          
          # Check frontend service
          FRONTEND_CHECK=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }})
          if [ "$FRONTEND_CHECK" != "200" ]; then
            echo "Frontend health check failed with status $FRONTEND_CHECK"
            exit 1
          fi
          
          # Check backend API health endpoint
          BACKEND_CHECK=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }}/api/health)
          if [ "$BACKEND_CHECK" != "200" ]; then
            echo "Backend health check failed with status $BACKEND_CHECK"
            exit 1
          fi
          
          echo "All health checks passed!"
          
      - name: Notify deployment success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "✅ Successfully deployed to ${{ needs.prepare.outputs.environment }} (version: ${{ needs.prepare.outputs.version }})\nApplication available at: https://${{ env.DOMAIN }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
          
      - name: Notify deployment failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "❌ Deployment to ${{ needs.prepare.outputs.environment }} failed (version: ${{ needs.prepare.outputs.version }})\nSee details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

            # New job for creating tags
  create-tag:
    name: Create Semantic Version Tag
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: needs.deploy.result == 'success' && github.ref == 'refs/heads/master'
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Ensures all history is fetched for tag creation

      - name: Bump version and push tag
        uses: anothrNick/github-tag-action@1.64.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WITH_V: true
          RELEASE_BRANCHES: master
          DEFAULT_BUMP: patch  # Automatically bump patch version on successful deployment

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Optional: Send notification about new release
      - name: Notify Release
        uses: slackapi/slack-github-action@v1.24.0
        if: success()
        with:
          payload: |
            {
              "text": "🚀 New Release Created: ${{ steps.tag.outputs.tag }}\nDeployed to: ${{ needs.prepare.outputs.environment }}\nView release notes: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.tag.outputs.tag }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Enhanced Slack Notification Job
  deployment-notification:
    name: Extended Deployment Notification
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: always()  # Run even if previous jobs failed
    steps:
      - name: Detailed Deployment Notification
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "🚀 Deployment ${{ needs.deploy.result == 'success' && 'Successful' || 'Failed' }}"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Environment:*\n${{ needs.prepare.outputs.environment }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ needs.prepare.outputs.version }}"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "Deployment result: ${{ needs.deploy.result }}\nView workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}