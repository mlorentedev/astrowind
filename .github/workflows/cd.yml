name: Continuous Deployment

on:
  # Trigger when manually dispatched
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy'
        required: false
        type: string
      cleanup:
        description: 'Perform cleanup before deployment'
        required: false
        default: false
        type: boolean

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-env.outputs.version }}
      domain: ${{ steps.set-env.outputs.domain }}
    steps:   
      - name: Set environment and version
        id: set-env
        run: |
          # For workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            
            if [[ -n "${{ github.event.inputs.version }}" ]]; then
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
              echo "version=latest" >> $GITHUB_OUTPUT
            else
              echo "version=develop" >> $GITHUB_OUTPUT
            fi
          
          # For repository_dispatch  
          elif [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            if [[ "${{ github.event.client_payload.ref }}" == "refs/heads/master" ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
            else
              echo "environment=staging" >> $GITHUB_OUTPUT
            fi
            echo "version=${{ github.event.client_payload.version }}" >> $GITHUB_OUTPUT
          fi
          
          # Set domain based on environment
          if [[ "${{ steps.set-env.outputs.environment }}" == "production" ]]; then
            echo "domain=mlorente.dev" >> $GITHUB_OUTPUT
          else
            echo "domain=staging.mlorente.dev" >> $GITHUB_OUTPUT
          fi

  deploy:
    name: Deploy to ${{ needs.prepare.outputs.environment }}
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ needs.prepare.outputs.environment }}
    concurrency: 
      group: deploy-${{ needs.prepare.outputs.environment }}
      cancel-in-progress: false
    steps:
      - uses: actions/checkout@v4

      - name: Download deployment artifacts
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts
          path: deployment
          repository: ${{ github.repository }}
          run-id: ${{ github.event.client_payload.run_id || github.run_id }}
          github-token: ${{ secrets.REPO_TOKEN }}
          
      - name: Set environment variables
        run: |
          if [[ "${{ needs.prepare.outputs.environment }}" == "production" ]]; then
            echo "SSH_HOST=${{ secrets.PRODUCTION_DOMAIN }}" >> $GITHUB_ENV
            echo "SSH_USER=${{ secrets.PRODUCTION_USERNAME }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=/opt/mlorente.dev" >> $GITHUB_ENV
            echo "COMPOSE_FILE=docker-compose.production.yml" >> $GITHUB_ENV
            echo "DOMAIN=mlorente.dev" >> $GITHUB_ENV
          else
            echo "SSH_HOST=${{ secrets.STAGING_DOMAIN }}" >> $GITHUB_ENV
            echo "SSH_USER=${{ secrets.STAGING_USERNAME }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=/opt/mlorente-staging" >> $GITHUB_ENV
            echo "COMPOSE_FILE=docker-compose.staging.yml" >> $GITHUB_ENV
            echo "DOMAIN=staging.mlorente.dev" >> $GITHUB_ENV
          fi

      # Setup SSH
      - uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      # Add the host key to known_hosts
      - name: Add SSH host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      # Prepare deployment script
      - name: Create deployment script
        run: |
          cat > deploy.sh <<'EOL'
          #!/bin/bash
          set -e
          
          # Deployment variables
          ENV="${{ needs.prepare.outputs.environment }}"
          VERSION="${{ needs.prepare.outputs.version }}"
          DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
          DOMAIN="${{ env.DOMAIN }}"
          COMPOSE_FILE="${{ env.COMPOSE_FILE }}"
          EMAIL="${{ secrets.PUBLIC_SITE_MAIL }}"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          echo "===== STARTING DEPLOYMENT ====="
          echo "Environment: ${ENV}"
          echo "Version: ${VERSION}"
          echo "Directory: ${DEPLOY_PATH}"
          echo "Domain: ${DOMAIN}"
          echo "==============================="
          
          # Create backup directory
          BACKUP_DIR="${DEPLOY_PATH}/backups/${TIMESTAMP}"
          mkdir -p "${BACKUP_DIR}"
          
          # Backup existing files
          if [ -d "${DEPLOY_PATH}/core" ]; then
            echo "Creating backup of current configuration..."
            cp -r "${DEPLOY_PATH}/core" "${BACKUP_DIR}/"
          fi
          
          # Create Docker network if not exists
          docker network create traefik_network 2>/dev/null || true
          
          # Transfer deployment files
          echo "Transferring deployment files..."
          mkdir -p ${DEPLOY_PATH}/core/infrastructure
          cp -r deployment/core/infrastructure/docker-compose ${DEPLOY_PATH}/core/infrastructure/
          cp -r deployment/core/infrastructure/scripts ${DEPLOY_PATH}/core/infrastructure/
          cp -r deployment/core/infrastructure/traefik ${DEPLOY_PATH}/core/infrastructure/
          
          # Make scripts executable
          chmod +x ${DEPLOY_PATH}/core/infrastructure/scripts/*.sh
          
          # Create .env file
          cat > ${DEPLOY_PATH}/.env << EOF
          # Environment
          ENVIRONMENT=${ENV}
          VERSION=${VERSION}
          
          # Domain
          DOMAIN=${DOMAIN}
          EMAIL=${EMAIL}
          
          # Docker
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          
          # Additional variables
          TRAEFIK_DASHBOARD=${{ secrets.TRAEFIK_DASHBOARD || 'false' }}
          TRAEFIK_INSECURE=${{ secrets.TRAEFIK_INSECURE || 'false' }}
          TRAEFIK_BASICAUTH=${{ secrets.TRAEFIK_BASICAUTH }}
          EOF
          
          # Perform cleanup if requested
          if [ "${{ github.event.inputs.cleanup }}" = "true" ]; then
            echo "Performing cleanup..."
            cd "${DEPLOY_PATH}"
            ./core/infrastructure/scripts/cleanup.sh
          fi
          
          # Generate Traefik configuration
          echo "Generating Traefik configuration..."
          cd "${DEPLOY_PATH}"
          ./core/infrastructure/scripts/generate-traefik-config.sh
          
          # Deploy common services
          echo "Deploying common services..."
          cd "${DEPLOY_PATH}"
          ./core/infrastructure/scripts/deploy.sh deploy common
          
          # Deploy environment-specific services
          echo "Deploying ${ENV} environment..."
          ./core/infrastructure/scripts/deploy.sh deploy ${ENV}
          
          # Wait for services to start
          echo "Waiting for services to start..."
          sleep 10
          
          # Verify deployment
          echo "Checking deployment status..."
          COMPOSE_FILE=./core/infrastructure/docker-compose/${COMPOSE_FILE}
          if docker-compose -f ${COMPOSE_FILE} ps | grep -q "Exit"; then
            echo "Deployment failed! Container exited."
            docker-compose -f ${COMPOSE_FILE} logs
            exit 1
          fi
          
          echo "Deployment completed successfully!"
          EOL
          
          chmod +x deploy.sh
      
      - name: Transfer deployment script
        run: scp deploy.sh ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/deploy.sh
      
      - name: Transfer deployment files
        run: |
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p /tmp/deployment"
          scp -r deployment/* ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/deployment/
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}"
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cp -r /tmp/deployment/* ${{ env.DEPLOY_PATH }}/"
      
      - name: Execute deployment
        run: ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cd ${{ env.DEPLOY_PATH }} && /tmp/deploy.sh"

      - name: Verify deployment
        run: |
          echo "Running health checks..."
          sleep 15
          
          # Check frontend
          FRONTEND_CHECK=$(curl -s -o /dev/null -w "%{http_code}" https://${{ needs.prepare.outputs.domain }})
          if [ "$FRONTEND_CHECK" != "200" ]; then
            echo "Frontend check failed: $FRONTEND_CHECK"
            exit 1
          fi
          
          echo "âœ… All health checks passed!"

  release:
    name: Create Release
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: needs.prepare.outputs.environment == 'production' && (github.event_name == 'repository_dispatch' && github.event.client_payload.ref == 'refs/heads/master')
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Create release version
        id: semver
        uses: anothrNick/github-tag-action@1.64.0
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_TOKEN }}
          WITH_V: true
          DEFAULT_BUMP: patch
      
      - name: Download release package
        uses: actions/download-artifact@v4
        with:
          name: release-package
          path: .
          repository: ${{ github.repository }}
          run-id: ${{ github.event.client_payload.run_id || github.run_id }}
          github-token: ${{ secrets.REPO_TOKEN }}
      
      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.semver.outputs.new_tag }}
          name: Release ${{ steps.semver.outputs.new_tag }}
          generate_release_notes: true
          files: release-artifacts.zip
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_TOKEN }}
      
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Tag and push Docker images
        run: |
          VERSION="${{ steps.semver.outputs.new_tag }}"
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-jekyll:latest
          
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-jekyll:latest ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-jekyll:${VERSION}
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-jekyll:${VERSION}
          
          # Also tag backend if it exists
          if docker pull ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:latest 2>/dev/null; then
            docker tag ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:latest ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:${VERSION}
            docker push ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:${VERSION}
          fi
      
      - name: Notify release
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "ðŸš€ New Release: ${{ steps.semver.outputs.new_tag }} has been created and deployed to production."
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}