name: CD Pipeline

on:
  # Trigger when an event is dispatched to the repository like a Webhook
  repository_dispatch:
    types: [trigger-deploy]
  # Trigger when a workflow is manually dispatched
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy'
        required: false
        type: string
  # Trigger when a pull request is closed and merged
  pull_request:
    types: [closed]
    branches: [master, develop]

jobs:
  prepare:
    name: Prepare Deployment
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request' || github.event.pull_request.merged == true
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      version: ${{ steps.set-env.outputs.version }}
    steps:   
      - name: Set environment and version
        id: set-env
        run: |
          # For workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            
            if [[ -n "${{ github.event.inputs.version }}" ]]; then
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
            elif [[ "${{ github.event.inputs.environment }}" == "production" ]]; then
              echo "version=latest" >> $GITHUB_OUTPUT
            else
              echo "version=develop" >> $GITHUB_OUTPUT
            fi
          
          # For repository_dispatch  
          elif [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            if [[ "${{ github.event.client_payload.ref }}" == "refs/heads/master" ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
            else
              echo "environment=staging" >> $GITHUB_OUTPUT
            fi
            echo "version=${{ github.event.client_payload.version }}" >> $GITHUB_OUTPUT
          
          # For pull_request merged  
          else
            if [[ "${{ github.event.pull_request.base.ref }}" == "master" ]]; then
              echo "environment=production" >> $GITHUB_OUTPUT
              echo "version=latest" >> $GITHUB_OUTPUT
            else
              echo "environment=staging" >> $GITHUB_OUTPUT
              echo "version=develop" >> $GITHUB_OUTPUT
            fi
          fi

  deploy:
    name: Deploy to ${{ needs.prepare.outputs.environment }}
    needs: prepare
    runs-on: ubuntu-latest
    environment: ${{ needs.prepare.outputs.environment }}
    concurrency: 
      group: deploy-${{ needs.prepare.outputs.environment }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Set environment variables
        run: |
          if [[ "${{ needs.prepare.outputs.environment }}" == "production" ]]; then
            echo "SSH_HOST=${{ secrets.PRODUCTION_HOST }}" >> $GITHUB_ENV
            echo "SSH_USER=${{ secrets.PRODUCTION_USERNAME }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=/opt/mlorente" >> $GITHUB_ENV
            echo "DOMAIN=mlorente.dev" >> $GITHUB_ENV
          else
            echo "SSH_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
            echo "SSH_USER=${{ secrets.STAGING_USERNAME }}" >> $GITHUB_ENV
            echo "DEPLOY_PATH=/opt/mlorente-staging" >> $GITHUB_ENV
            echo "DOMAIN=staging.mlorente.dev" >> $GITHUB_ENV
          fi

      # Setup SSH - Use the webfactory action which handles SSH properly
      - uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      
      # Add the host key to known_hosts
      - name: Add SSH host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ env.SSH_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      # Create and run deployment script
      - name: Deploy to server
        run: |
          # Crear deploy.sh
          cat > deploy.sh <<'EOL'
          #!/bin/bash
          set -e
          
          # Deployment variables
          ENV="${{ needs.prepare.outputs.environment }}"
          VERSION="${{ needs.prepare.outputs.version }}"
          DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
          DOMAIN="${{ env.DOMAIN }}"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          
          echo "===== STARTING DEPLOYMENT ====="
          echo "Environment: ${ENV}"
          echo "Version: ${VERSION}"
          echo "Directory: ${DEPLOY_PATH}"
          echo "Domain: ${DOMAIN}"
          echo "==============================="
          
          # Backup existing configuration
          BACKUP_DIR="${DEPLOY_PATH}/backups/${TIMESTAMP}"
          mkdir -p "${BACKUP_DIR}"
          [ -f "${DEPLOY_PATH}/backend/.env" ] && cp "${DEPLOY_PATH}/backend/.env" "${BACKUP_DIR}/backend.env.backup"
          [ -f "${DEPLOY_PATH}/frontend/.env" ] && cp "${DEPLOY_PATH}/frontend/.env" "${BACKUP_DIR}/frontend.env.backup"
          [ -f "${DEPLOY_PATH}/docker-compose.yml" ] && cp "${DEPLOY_PATH}/docker-compose.yml" "${BACKUP_DIR}/docker-compose.yml.backup"
          [ -d "${DEPLOY_PATH}/docker/nginx" ] && cp -r "${DEPLOY_PATH}/docker/nginx" "${BACKUP_DIR}/nginx.backup"
          
          # Set environment variables for deployment
          cd "${DEPLOY_PATH}"
          export TAG="${VERSION}"
          export DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
          
          # Replace placeholders in Nginx configuration if needed
          if [ -f "${DEPLOY_PATH}/docker/nginx/conf.d/default.conf" ]; then
            sed -i "s/\${DOMAIN}/${DOMAIN}/g" "${DEPLOY_PATH}/docker/nginx/conf.d/default.conf"
          fi
          
          # Pull and deploy
          docker-compose pull
          docker-compose up -d
          
          # Verify deployment
          sleep 10
          if ! docker-compose ps | grep -q "Up"; then
            echo "ERROR: Deployment verification failed!"
            docker-compose logs
            exit 1
          fi
          
          # Clean up old images
          docker image prune -af --filter "until=24h" || true
          
          echo "===== DEPLOYMENT COMPLETED ====="
          EOL
          
          chmod +x deploy.sh
          
          # Crear directorios para archivos .env
          mkdir -p backend frontend
              
          # Crear archivo .env para el backend (siguiendo la estructura de backend.env.example)
          cat > backend/.env << EOF
          # Environment
          ENV=${{ needs.prepare.outputs.environment }}
          VERSION=${{ needs.prepare.outputs.version }}
          PORT=8080
          
          # Application
          SITE_TITLE=${{ secrets.PUBLIC_SITE_TITLE }}
          SITE_AUTHOR=${{ secrets.PUBLIC_SITE_AUTHOR }}
          SITE_DOMAIN=${{ env.DOMAIN }}
          SITE_MAIL=${{ secrets.PUBLIC_SITE_MAIL }}
          SITE_URL=https://${{ env.DOMAIN }}
          
          # Newsletter & Subscription Service
          BEEHIIV_API_KEY=${{ secrets.BEEHIIV_API_KEY }}
          BEEHIIV_PUB_ID=${{ secrets.BEEHIIV_PUB_ID }}
          
          # Email Configuration
          EMAIL_HOST=${{ secrets.EMAIL_HOST }}
          EMAIL_PORT=${{ secrets.EMAIL_PORT }}
          EMAIL_FROM=${{ secrets.EMAIL_FROM }}
          EMAIL_SECURE=true
          EMAIL_USER=${{ secrets.EMAIL_USER }}
          EMAIL_PASS=${{ secrets.EMAIL_PASS }}
          EOF
          
          # Crear archivo .env para el frontend (siguiendo la estructura de frontend.env.example)
          cat > frontend/.env << EOF
          # Environment
          ENV=${{ needs.prepare.outputs.environment }}
          VERSION=${{ needs.prepare.outputs.version }}
          
          # Application
          PUBLIC_SITE_TITLE=${{ secrets.PUBLIC_SITE_TITLE }}
          PUBLIC_SITE_DESCRIPTION=${{ secrets.PUBLIC_SITE_DESCRIPTION }}
          PUBLIC_SITE_DOMAIN=${{ env.DOMAIN }}
          PUBLIC_SITE_URL=https://${{ env.DOMAIN }}
          PUBLIC_SITE_MAIL=${{ secrets.PUBLIC_SITE_MAIL }}
          PUBLIC_SITE_AUTHOR=${{ secrets.PUBLIC_SITE_AUTHOR }}
          PUBLIC_SITE_KEYWORDS=${{ secrets.PUBLIC_SITE_KEYWORDS }}
          
          # Social media
          PUBLIC_CALENDLY_URL=${{ secrets.PUBLIC_CALENDLY_URL }}
          PUBLIC_TWITTER_URL=${{ secrets.PUBLIC_TWITTER_URL }}
          PUBLIC_YOUTUBE_URL=${{ secrets.PUBLIC_YOUTUBE_URL }}
          PUBLIC_GITHUB_URL=${{ secrets.PUBLIC_GITHUB_URL }}
          
          # Feature flags
          PUBLIC_ENABLE_BLOG=${{ secrets.PUBLIC_ENABLE_BLOG }}
          PUBLIC_ENABLE_HOMELABS=${{ secrets.PUBLIC_ENABLE_HOMELABS }}
          PUBLIC_ENABLE_CONTACT=${{ secrets.PUBLIC_ENABLE_CONTACT }}
          
          # Analytics & Tracking
          PUBLIC_GOOGLE_ANALYTICS_ID=${{ secrets.PUBLIC_GOOGLE_ANALYTICS_ID }}
          PUBLIC_GOOGLE_TAG_MANAGER_ID=${{ secrets.PUBLIC_GOOGLE_TAG_MANAGER_ID }}
          
          # Backend URL (para acceso interno en Docker)
          BACKEND_URL=http://backend:8080
          EOF
          
          # Copiar archivos al servidor
          scp deploy.sh ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/deploy.sh
          scp docker-compose.yml ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/docker-compose.yml
          scp -r backend ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/
          scp -r frontend ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/
          
          if [ -d "docker/nginx" ]; then
            ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p /tmp/docker/nginx"
            scp -r docker/nginx/* ${{ env.SSH_USER }}@${{ env.SSH_HOST }}:/tmp/docker/nginx/
          fi    

          # Crear directorios en el path de despliegue
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}/docker/nginx/conf.d"
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}/backend"
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "mkdir -p ${{ env.DEPLOY_PATH }}/frontend"
          
          # Mover archivos de /tmp al directorio de despliegue
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cp /tmp/backend/.env ${{ env.DEPLOY_PATH }}/backend/"
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cp /tmp/frontend/.env ${{ env.DEPLOY_PATH }}/frontend/"
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cp /tmp/docker-compose.yml ${{ env.DEPLOY_PATH }}/"
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cp -r /tmp/docker/nginx/* ${{ env.DEPLOY_PATH }}/docker/nginx/"
          
          # Ejecutar script de despliegue
          ssh ${{ env.SSH_USER }}@${{ env.SSH_HOST }} "cd ${{ env.DEPLOY_PATH }} && /tmp/deploy.sh"   

      - name: Verify deployment
        run: |
          echo "Running health checks..."
          sleep 15
          
          # Check frontend
          FRONTEND_CHECK=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }})
          if [ "$FRONTEND_CHECK" != "200" ]; then
            echo "Frontend check failed: $FRONTEND_CHECK"
            exit 1
          fi
          
          # Check backend API
          BACKEND_CHECK=$(curl -s -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }}/health)
          if [ "$BACKEND_CHECK" != "200" ]; then
            echo "Backend check failed: $BACKEND_CHECK"
            exit 1
          fi
          
          echo "✅ All health checks passed!"

  release:
    name: Create Release
    needs: [prepare, deploy]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'master'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # Create semantic version tag
      - name: Create release version
        id: semver
        uses: anothrNick/github-tag-action@1.64.0
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_TOKEN }}
          WITH_V: true
          DEFAULT_BUMP: patch
      
      # Create GitHub release
      - name: Create GitHub release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.semver.outputs.new_tag }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.REPO_TOKEN }}
      
      # Push release tag to Docker images
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Tag and push Docker images
        run: |
          VERSION="${{ steps.semver.outputs.new_tag }}"
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-frontend:latest
          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:latest
          
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-frontend:latest ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-frontend:${VERSION}
          docker tag ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:latest ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:${VERSION}
          
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-frontend:${VERSION}
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/mlorente-backend:${VERSION}
      
      # Notify about release
      - name: Notify release
        uses: slackapi/slack-github-action@v1.24.0
        with:
          payload: |
            {
              "text": "🚀 New Release: ${{ steps.semver.outputs.new_tag }} has been created and deployed to production."
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}